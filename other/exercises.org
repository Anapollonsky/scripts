Just some programming exercises.
* trees
** Building tree from inorder and postorder.
Assignment: 
*** tree 1
       a
    b     c
  d   e    f
   g      h    
+ inorder:  dgbeachf
+ postorder: gdebhfca
*** tree 2
    f
  h
+ inorder:  hf
+ postorder: hf

*** tree 3
b
  e
+ inorder: be
+ postorder: eb

*** tree 4
g
+ inorder: g
+ postorder: g
*** solution
#+BEGIN_SRC python
  inorder = ['d', 'g', 'b', 'e', 'a', 'c', 'h', 'f']
  postorder  = ['g', 'd', 'e', 'b', 'h', 'f', 'c', 'a']
  def build_tree(ino, posto):
      if len(ino) == 0:
          return None
      elif len(ino) == 1:
          return (ino, None, None)
      curnode = posto[-1]
      in_index = ino.index(curnode)
      leftin = ino[0:in_index]
      rightin = ino[in_index+1:]
      leftpost = posto[0:in_index]
      rightpost = posto[in_index:-1]
      left = build_tree(leftin, leftpost)
      right = build_tree(rightin, rightpost)
      return (curnode, left, right)
  return build_tree(inorder, postorder)        
#+END_SRC

#+RESULTS:
| a | (b (d None ((g) None None)) ((e) None None)) | (c None (f ((h) None None) None)) |

 
** Lowest common ancestor
*** Generic tree, multiple common values
Tries to find the closest common ancestor in a tree between a list of values. Little error-checking is done.
   a
  b  c
    d  e

#+BEGIN_SRC python
  #!/usr/bin/env python

  tree = ('a', ('b', None, None), ('c', ('d', None, None), ('e', None, None)))

  def lowest_common_ancestor(vals, head):
      ancestor_paths = lowest_common_ancestor_helper(vals, head, [], {})
      print ancestor_paths
      bestans = head[0]
      for k in ancestor_paths[vals[0]]:
          for q in ancestor_paths:
              if k not in ancestor_paths[q]:
                  return bestans
          bestans = k
      return bestans
          

  def lowest_common_ancestor_helper(vals, head, path, ans):
      for k in vals:
          if k == head[0]:
              ans[k] = path    
      if head[1] != None:
          x = list(path)
          x.append(head[0])
          lowest_common_ancestor_helper(vals, head[1], x, ans)
      if head[2] != None:
          x = list(path)
          x.append(head[0])        
          lowest_common_ancestor_helper(vals, head[2], x, ans)
      return ans

  return lowest_common_ancestor(['d', 'e'], tree)

#+END_SRC

#+RESULTS:
: c

*** BST, two common values
Assumes tree is a BST, only takes two values.
    5
   3  7
 1 4 6 8

#+BEGIN_SRC python
  tree = (5, (3, (1, None, None), (4, None, None)), (7, (6, None, None), (8, None, None)))

  def lowest_common_ancestor(a, b, tree):
      if (min(a,b) < tree[0]) and (max(a,b) > tree[0]):
          return tree[0]
      elif b < tree[0]:
          return lowest_common_ancestor(a, b, tree[1])
      else:
          return lowest_common_ancestor(a, b, tree[2])

  return lowest_common_ancestor(6, 4, tree)
      
#+END_SRC 

#+RESULTS:
: 5

** Balance an unbalance BST
Balance a tree, knowing that the left side is larger than the right.
       7
     5   8
   4  6
 3

#+BEGIN_SRC python
tree = [7, [5, [4, [3, [2, None, None], None], None], [6, None, None]], [8, None, None]]

def balance_once(head):
    old_head = list(head)
    head = head[1]
    old_head[1] = head[2]
    head[2] = old_head
    return head

return balance_once(tree)
#+END_SRC

#+RESULTS:
| 5 | (4 (3 (2 None None) None) None) | (7 (6 None None) (8 None None)) |

* Graph
** Six degrees of Kevin Bacon
Given a 'list' of movies and their associated cast, devise and implement a way to find the shortest path between any actor and Kevin Bacon.

*** Strategy
Actors are nodes, movies are edges between them.

Start at actor. Breadth first search of all neighbors. Maintain dictionary of visited actors and shortest paths to them. Once all actors exhausted or no more moves available, return shortest path to Kevin Bacon.

Visit a node if never visited. Update path. New path will never be shorter than old due to this being a breadth-first search.

#+BEGIN_SRC python
  from collections import deque

  class actor:
      def __init__(self, name, neighbors):
          self.name = name
          self.neighbors = neighbors
          
      def getneighbors(self):
          return self.neighbors

      def setneighbors(self, neighbors):
          self.neighbors = neighbors

      def getname(self):
          return self.name        

  w = actor('w', [])
  x = actor('x', [])
  y = actor('y', [])
  z = actor('z', [])

  w.setneighbors([z, y])
  x.setneighbors([y])
  y.setneighbors([x, z, w])
  z.setneighbors([y, w])


  def shortest_path(init, searchee):
      path_dict = {}
      Q = deque()
      Q.append(init)
      path_dict[init] = []
      while Q:
          acts_visited = {}
          curnode = Q.pop()
          if curnode == searchee:
              path_dict[searchee].append(searchee)
              return path_dict[searchee]
          for k in curnode.getneighbors():
              if (k not in acts_visited) and k not in path_dict:
                  Q.append(k)
                  path_dict[k] = list(path_dict[curnode])
                  path_dict[k].append(curnode)

  return [k.getname() for k in shortest_path(x, z)]                

#+END_SRC

#+RESULTS:
| x | y | z |

