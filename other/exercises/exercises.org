Just some programming exercises.
* EPI
** Stacks & Queues (8)
*** Path Cleaning (8)
Clean up a path name, dealing with ., .., and // in path names.
#+BEGIN_SRC python :results output
  from collections import deque

  def clean_path(pathname):
      stack = deque()
      word = ""
      for char in pathname:
          if char == "/":
              if word == "." or word == "":
                  pass
              elif word == "..":
                  stack.pop()
              else:
                  stack.append(word)
              word = ""
          else:
              word = word + char
      if word:
          stack.append(word)
      return "/".join(stack)

  print(clean_path("scripts//./../scripts/awkscripts/././"))
  print(clean_path("/usr/lib/../bin/gcc"))


#+END_SRC

#+RESULTS:
: scripts/awkscripts
: usr/bin/gcc

*** Queue from Two Stacks (12)
#+BEGIN_SRC python :results output 
  from collections import deque

  class stack2q(object):

      def __init__(self, vals=[]):
          self.stack1 = deque()
          self.stack2 = deque()
          for k in vals:
              self.enq(k)

      def enq(self, value):
          while self.stack1:
              self.stack2.append(self.stack1.pop())
          self.stack1.append(value)
          while self.stack2:
              self.stack1.append(self.stack2.pop())

      def deq(self):
          return self.stack1.pop()

  test = stack2q([1, 2, 3, 4])
  print(test.deq())
  print(test.deq())
  print(test.deq())
#+END_SRC

#+RESULTS:
: 1
: 2
: 3

*** Queue with Max (13)

#+BEGIN_SRC python :results output
  from collections import deque


  class maxq(object):
      def __init__(self, inval=[]):
          self.valq = deque()
          self.maxq = deque()
          for k in inval:
              self.enq(k)

      def enq(self, value):
          self.valq.append(value)
          if self.maxq:
              self.maxq.append(max(value, self.maxq[-1]))
          else:
              self.maxq.append(value)

      def deq(self):
          self.maxq.pop()
          return self.valq.pop()

      def get_max(self):
          return self.maxq[-1]

  test = maxq([1, 2, 3])
  print(test.get_max())
  test.enq(5)
  print(test.get_max())
  test.enq(2)
  print(test.get_max())
  test.enq(7)
  print(test.get_max())
  test.deq()
  print(test.get_max())
  test.deq()
  print(test.get_max())
  test.deq()
  print(test.get_max())
  test.deq()
  print(test.get_max())
#+END_SRC

#+RESULTS:
: 3
: 5
: 5
: 7
: 5
: 5
: 3
: 2

*** Maximum of a Sliding Window (14)
#+BEGIN_SRC python :results output
  from collections import deque

  def window_max(data, window_size):
      """Find maximum of sliding window, assume data is list of 2-ples"""
      actual_size = 0
      max_sum = 0
      current_sum = 0
      queue = deque()

      for k in data:
          if actual_size < window_size:
              queue.append(k)
              actual_size += 1
              current_sum += k[1]
              if current_sum > max_sum:
                  max_sum = current_sum
              continue
          queue.append(k)
          current_sum = current_sum + k[1] - queue.popleft()[1]
          if current_sum > max_sum:
              max_sum = current_sum
      return max_sum

  data = list(zip([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 5, 2, 6, 8, 3, 1, 1, 2]))
      
  print(window_max(data, 2))
  print(window_max(data, 3))
  print(window_max(data, 4))
  print(window_max(data, 5))
  print(window_max(data, 7))
  
#+END_SRC

#+RESULTS:
: 14
: 17
: 21
: 24
: 28

** Binary Tree (9)
*** Basic tree implementation
#+BEGIN_SRC python :results output :tangle tree.py
  from copy import deepcopy

  class tree(object):
      """ Simple tree implementation, where a tree is a list of lists (of lists), leaves are
      lists with a single entry, and any subsequent entries represent children."""
      def __init__(self, rootval, children=[]):
          if isinstance(rootval, list):
              self.value = rootval[0]
              self.children = []
              for k in rootval[1:]:
                  if k:
                      self.add_child(tree(k))
          else:
              self.value = rootval
              self.children = children

      def __repr__(self):
          return str(self.to_list())

      def get_val(self):
          return self.value

      def add_child(self, node):
          self.children.append(node)

      def get_child(self, num):
          return self.children[num]

      def get_children(self):
          return self.children

      def get_depths(self, start_depth=0):
          data = [start_depth]
          for child in self.get_children():
              for child_datum in child.get_depths(start_depth + 1):
                  data.append(child_datum)
          return data

      def to_list(self):
          temp = list(self.children)
          temp.insert(0, self.value)
          return temp


  class binary_tree(tree):

      def __init__(self, rootval, children=[]):
          if isinstance(rootval, list):
              self.value = rootval[0]
              self.children = []
              for k in rootval[1:]:
                  if k:
                      self.add_child(binary_tree(k))
          else:
              self.value = rootval
              self.children = children

      def left(self):
          if len(self.children) > 0 and isinstance(self.children[0], binary_tree):
              return self.children[0]
          else:
              return None

      def right(self):
          if len(self.children) > 1 and isinstance(self.children[1], binary_tree):
              return self.children[1]
          else:
              return None

      def get_tree_height(self):
          left_height = self.left().get_tree_height() if self.left() else 0
          right_height = self.right().get_tree_height() if self.right() else 0
          return 1 + max(left_height, right_height)

      ## 9.1: Check if balanced
      def is_balanced(self):
          """ Return height of tree, or None if not balanced"""
          left_height = self.left().is_balanced() if self.left() else 0
          right_height = self.right().is_balanced() if self.right() else 0
          if left_height == None or right_height == None or abs(right_height -
                                                        left_height) > 1:
              return None
          else:
              return 1 + max(left_height, right_height)

      ## 9.2: k-balanced nodes
      # def kbalanced(self)

      ## 9.3 symmetric tree
      def is_symmetric(self):
          def symmetric_helper(left_node, right_node):
              if bool(left_node) != bool(right_node):
                  return False
              if not (left_node or right_node):
                  return True
              if not left_node.get_val() == right_node.get_val():
                  return False
              return (symmetric_helper(left_node.left(), right_node.right())
                      and symmetric_helper(left_node.right(), right_node.left()))
          return symmetric_helper(self.left(), self.right())

      ## 9.7 reconstruct from inorder and preorder or postorder
      @staticmethod
      def rec_inord_preord(inorder, preorder):
          if len(inorder) == 0:
              return None
          rootindex = inorder.index(preorder[0])
          root = binary_tree(preorder[0])
          leftroot = binary_tree.rec_inord_preord(inorder[:rootindex], preorder[1:1+rootindex])
          # print(leftroot)
          root.add_child(leftroot)
          root.add_child(binary_tree.rec_inord_preord(inorder[rootindex+1:], preorder[rootindex+1:]))
          return root

  testtree = binary_tree([3, [1, [2, [3, [4]]]], [3, [2], [3]]])
  balanced_tree = binary_tree([3, [2, [1], [3]], [2, [3], [3]]])
  symmetric_tree = binary_tree([3, [2, [3], [2]], [2, [2], [3]]])
  # print(testtree.get_depths())
  # print(testtree.is_balanced())
  # print(balanced_tree.is_balanced())
  # print(testtree.is_symmetric())
  # print(symmetric_tree.is_symmetric())

  chartree = binary_tree(['H', ['B', ['F', None, None], ['E', ['A', None, None], None]], ['C', None, ['D', None, ['G', ['I', None, None], None]]]])
  chartree_inorder = ['F', 'B', 'A', 'E', 'H', 'C', 'D', 'I', 'G']
  chartree_preorder = ['H', 'B', 'F', 'E', 'A', 'C', 'D', 'G', 'I']
  nc = binary_tree.rec_inord_preord(chartree_inorder, chartree_preorder)
  print("test2")
  # print(chartree.to_list())
  # print(nc.children)

#+END_SRC

#+RESULTS:
: [0, 1, 2, 3, 4, 1, 2, 2]
: 2
: 2

*** Check Balance (1)
#+BEGIN_SRC python

#+END_SRC
* Trees
** Building tree from inorder and postorder.
Assignment: 
*** tree 1
       a
    b     c
  d   e    f
   g      h    
+ inorder:  dgbeachf
+ postorder: gdebhfca
*** tree 2
    f
  h
+ inorder:  hf
+ postorder: hf

*** tree 3
b
  e
+ inorder: be
+ postorder: eb

*** tree 4
g
+ inorder: g
+ postorder: g
*** solution
#+BEGIN_SRC python
  inorder = ['d', 'g', 'b', 'e', 'a', 'c', 'h', 'f']
  postorder  = ['g', 'd', 'e', 'b', 'h', 'f', 'c', 'a']
  def build_tree(ino, posto):
      if len(ino) == 0:
          return None
      elif len(ino) == 1:
          return (ino, None, None)
      curnode = posto[-1]
      in_index = ino.index(curnode)
      leftin = ino[0:in_index]
      rightin = ino[in_index+1:]
      leftpost = posto[0:in_index]
      rightpost = posto[in_index:-1]
      left = build_tree(leftin, leftpost)
      right = build_tree(rightin, rightpost)
      return (curnode, left, right)
  return build_tree(inorder, postorder)        
#+END_SRC

#+RESULTS:
| a | (b (d None ((g) None None)) ((e) None None)) | (c None (f ((h) None None) None)) |

 
** Lowest common ancestor
*** Generic tree, multiple common values
Tries to find the closest common ancestor in a tree between a list of values. Little error-checking is done.
   a
  b  c
    d  e

#+BEGIN_SRC python
  #!/usr/bin/env python

  tree = ('a', ('b', None, None), ('c', ('d', None, None), ('e', None, None)))

  ## First call the helper, then use that dictionary to find lowest common member of the lists.
  def lowest_common_ancestor(vals, head):
      ancestor_paths = lowest_common_ancestor_helper(vals, head, [], {})
      print ancestor_paths
      bestans = head[0]
      for k in ancestor_paths[vals[0]]:
          for q in ancestor_paths:
              if k not in ancestor_paths[q]:
                  return bestans
          bestans = k
      return bestans
          
  ## Return a dictionary mapping each value we're looking at to a list repersenting its path.
  def lowest_common_ancestor_helper(vals, head, path, ans):
      for k in vals:
          if k == head[0]:
              ans[k] = path    
      if head[1] != None:
          x = list(path)
          x.append(head[0])
          lowest_common_ancestor_helper(vals, head[1], x, ans)
      if head[2] != None:
          x = list(path)
          x.append(head[0])        
          lowest_common_ancestor_helper(vals, head[2], x, ans)
      return ans

  return lowest_common_ancestor(['d', 'e'], tree)

#+END_SRC

#+RESULTS:
: c

*** BST, two common values
Assumes tree is a BST, only takes two values.
    5
   3  7
 1 4 6 8

#+BEGIN_SRC python
  tree = (5, (3, (1, None, None), (4, None, None)), (7, (6, None, None), (8, None, None)))

  def lowest_common_ancestor(a, b, tree):
      if (min(a,b) < tree[0]) and (max(a,b) > tree[0]):
          return tree[0]
      elif b < tree[0]:
          return lowest_common_ancestor(a, b, tree[1])
      else:
          return lowest_common_ancestor(a, b, tree[2])

  return lowest_common_ancestor(6, 4, tree)
      
#+END_SRC 

#+RESULTS:
: 5

** Balance an unbalanced BST
Balance a tree, knowing that the left side is larger than the right.
       7
     5   8
   4  6
 3

#+BEGIN_SRC python
tree = [7, [5, [4, [3, [2, None, None], None], None], [6, None, None]], [8, None, None]]

def balance_once(head):
    old_head = list(head)
    head = head[1]
    old_head[1] = head[2]
    head[2] = old_head
    return head

return balance_once(tree)
#+END_SRC

#+RESULTS:
| 5 | (4 (3 (2 None None) None) None) | (7 (6 None None) (8 None None)) |

* Graph
** Six degrees of Kevin Bacon
Given a 'list' of movies and their associated cast, devise and implement a way to find the shortest path between any actor and Kevin Bacon.

*** Strategy
Actors are nodes, movies are edges between them.

Start at actor. Breadth first search of all neighbors. Maintain dictionary of visited actors and shortest paths to them. Once all actors exhausted or no more moves available, return shortest path to Kevin Bacon.

Visit a node if never visited. Update path. New path will never be shorter than old due to this being a breadth-first search.

#+BEGIN_SRC python
  from collections import deque

  class actor:
      def __init__(self, name, neighbors):
          self.name = name
          self.neighbors = neighbors
          
      def getneighbors(self):
          return self.neighbors

      def setneighbors(self, neighbors):
          self.neighbors = neighbors

      def getname(self):
          return self.name        

  w = actor('w', [])
  x = actor('x', [])
  y = actor('y', [])
  z = actor('z', [])

  w.setneighbors([z, y])
  x.setneighbors([y])
  y.setneighbors([x, z, w])
  z.setneighbors([y, w])


  def shortest_path(init, searchee):
      path_dict = {}
      Q = deque()
      Q.append(init)
      path_dict[init] = []
      while Q:
          acts_visited = [] # In case there are two edges connecting same actors
          curnode = Q.pop()
          if curnode == searchee:
              path_dict[searchee].append(searchee)
              return path_dict[searchee]
          for k in curnode.getneighbors():
              if (k not in acts_visited) and k not in path_dict:
                  Q.append(k)
                  acts_visited.append(k)
                  path_dict[k] = list(path_dict[curnode])
                  path_dict[k].append(curnode)

  return [k.getname() for k in shortest_path(x, z)]                

#+END_SRC

#+RESULTS:
| x | y | z |

** Word-neighbors
You're given two words. Find the shortest path between them, where a single move entails switching a single letter in each word (or inserting one), and each intermediary step must be a valid word. 

First step is generating the neighbors for every word. This script does that, both for the case with only letter-swapping and then with letter-insertion as well. This is then pickled, so it doesn't have to be done again and again while testing.
#+BEGIN_SRC python
  import pickle

  f = open('wordlist.txt', 'r')
  wordlist = f.readlines()
  wordlist = [x.strip("\n").lower() for x in wordlist]
  wordict = {}
  for line in wordlist:
      wordict[line] = []
  f.close()

  letters = list('abcdefghijklmnopqrstuvwxyz')
  for word in wordlist:
      for i, letter in enumerate(list(word)): # Letter replacement
          for repletter in letters:
              neword = list(word)            
              neword[i] = repletter
              temp = "".join(neword)
              if temp in wordict and temp not in wordict[word]:
                  wordict[word].append(temp)
  pikl_file = open('replacement_wordict.pkl', 'wb') 
  pickle.dump(wordict, pikl_file)
  pikl_file.close()

  for word in wordlist:                
      for i in range(len(word)+1): # letter insertion
          for repletter in letters:
              neword = list(word)            
              neword.insert(i, repletter)
              temp = "".join(neword)
              if temp in wordict and temp not in wordict[word]:
                  wordict[word].append(temp)

  pikl_file = open('replacement_and_insertion_wordict.pkl', 'wb') 
  pickle.dump(wordict, pikl_file)
  pikl_file.close()                
#+END_SRC

#+RESULTS:
: None


This code implements a simple algorithm, which travels in a single direction between two words. It's inefficient, as looking searching for a match from two directions will search exponentially fewer words.
#+BEGIN_SRC python
  from collections import deque
  import pickle

  f = open('wordlist.txt', 'r')                      
  wordlist = f.readlines()                           
  wordlist = [x.strip("\n").lower() for x in wordlist]
  f.close()

  pikl_file = open('replacement_and_insertion_wordict.pkl', 'rb')
  wordict = pickle.load(pikl_file)
  pikl_file.close()
      
  def findpath(word1, word2):
      stack = deque()
      stack.append(word1)
      visitedWords = {word1:1}
      while 1:
          if stack:
              curnode = stack.popleft()
          else:
              return None
          for k in wordict[curnode]:
              if (k == word2):
                  m = visitedWords[curnode]
                  theanswer = [k, curnode]
                  while m != 1:
                      theanswer.append(m)
                      m = visitedWords[m]                    
                  return theanswer
              if k not in visitedWords:
                  visitedWords[k] = curnode
                  stack.append(k)

  return findpath('a', 'bent')

#+END_SRC

#+RESULTS:
| bent | ben | be | b | a |

This script does a similar thing, but instead of working with two words, it works for n words. And it's faster, because it approaches from all sides! Basically, it's looking for the shortest paths to connect all the given words.

#+BEGIN_SRC python
#!/usr/bin/env python
from collections import deque
import pickle

f = open('wordlist.txt', 'r')                      
wordlist = f.readlines()                           
wordlist = [x.strip("\n").lower() for x in wordlist]
f.close()

pikl_file = open('replacement_and_insertion_wordict.pkl', 'rb')
wordict = pickle.load(pikl_file)
pikl_file.close()

def findpath_multiple(input_list):
    visitedwords = [{word: None} for word in input_list]
    paths = [[] for word in input_list]
    deques = [deque() for word in input_list]
    curword = [1 for word in input_list]
    for k in range(len(deques)):
        deques[k].append(input_list[k])

    while 1:
        for commonword in visitedwords[0]:
            if all([commonword in visitedwords[x] for x in range(0, len(input_list))]):
                for i, word in enumerate(input_list):
                    m = commonword
                    while m != None:
                        paths[i].append(m)
                        m = visitedwords[i][m]
                return(commonword, paths)
        for i, word in enumerate(input_list):
            if deques[i]:
                curword[i] = deques[i].popleft()
            else:
                return None
            for neighbor in wordict[curword[i]]:
                if neighbor not in visitedwords[i]:
                    visitedwords[i][neighbor] = curword[i]
                    deques[i].append(neighbor)
        
return(findpath_multiple(['bath', 'kent', 'what']))
#+END_SRC

#+RESULTS:
| cast | ((cast cash bash bath) (cast cant cent kent) (cast cost coat chat what)) |

