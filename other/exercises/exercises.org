Just some programming exercises.
* EPI
A collection of exercises from the textbook "Elements of Programming Interviews". 
** 8 Stacks & Queues
*** 8 Path Cleaninggg (8)
Clean up a path name, dealing with ., .., and // in path names.
#+BEGIN_SRC python :results output
  from collections import deque

  def clean_path(pathname):
      stack = deque()
      word = ""
      for char in pathname:
          if char == "/":
              if word == "." or word == "":
                  pass
              elif word == "..":
                  stack.pop()
              else:
                  stack.append(word)
              word = ""
          else:
              word = word + char
      if word:
          stack.append(word)
      return "/".join(stack)

  print(clean_path("scripts//./../scripts/awkscripts/././"))
  print(clean_path("/usr/lib/../bin/gcc"))


#+END_SRC

#+RESULTS:
: scripts/awkscripts
: usr/bin/gcc

*** 12 Queue from Two Stacks
#+BEGIN_SRC python :results output 
  from collections import deque

  class stack2q(object):

      def __init__(self, vals=[]):
          self.stack1 = deque()
          self.stack2 = deque()
          for k in vals:
              self.enq(k)

      def enq(self, value):
          while self.stack1:
              self.stack2.append(self.stack1.pop())
          self.stack1.append(value)
          while self.stack2:
              self.stack1.append(self.stack2.pop())

      def deq(self):
          return self.stack1.pop()

  test = stack2q([1, 2, 3, 4])
  print(test.deq())
  print(test.deq())
  print(test.deq())
#+END_SRC

#+RESULTS:
: 1
: 2
: 3

*** 13 Queue with Max

#+BEGIN_SRC python :results output
  from collections import deque


  class maxq(object):
      def __init__(self, inval=[]):
          self.valq = deque()
          self.maxq = deque()
          for k in inval:
              self.enq(k)

      def enq(self, value):
          self.valq.append(value)
          if self.maxq:
              self.maxq.append(max(value, self.maxq[-1]))
          else:
              self.maxq.append(value)

      def deq(self):
          self.maxq.pop()
          return self.valq.pop()

      def get_max(self):
          return self.maxq[-1]

  test = maxq([1, 2, 3])
  print(test.get_max())
  test.enq(5)
  print(test.get_max())
  test.enq(2)
  print(test.get_max())
  test.enq(7)
  print(test.get_max())
  test.deq()
  print(test.get_max())
  test.deq()
  print(test.get_max())
  test.deq()
  print(test.get_max())
  test.deq()
  print(test.get_max())
#+END_SRC

#+RESULTS:
: 3
: 5
: 5
: 7
: 5
: 5
: 3
: 2

*** 14 Maximum of a Sliding Windoww
#+BEGIN_SRC python :results output
  from collections import deque

  def window_max(data, window_size):
      """Find maximum of sliding window, assume data is list of 2-ples"""
      actual_size = 0
      max_sum = 0
      current_sum = 0
      queue = deque()

      for k in data:
          if actual_size < window_size:
              queue.append(k)
              actual_size += 1
              current_sum += k[1]
              if current_sum > max_sum:
                  max_sum = current_sum
              continue
          queue.append(k)
          current_sum = current_sum + k[1] - queue.popleft()[1]
          if current_sum > max_sum:
              max_sum = current_sum
      return max_sum

  data = list(zip([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 5, 2, 6, 8, 3, 1, 1, 2]))
      
  print(window_max(data, 2))
  print(window_max(data, 3))
  print(window_max(data, 4))
  print(window_max(data, 5))
  print(window_max(data, 7))
  
#+END_SRC

#+RESULTS:
: 14
: 17
: 21
: 24
: 28

** 9 Binary Tree
*** Binary Tree Problems 
Many problems in the code-block below, due to the reliance on the same tree classes
#+BEGIN_SRC python :results output :tangle tree.py
  from copy import deepcopy
  from collections import deque

  class tree(object):
      """ Simple tree implementation, where a tree is a list of lists (of lists), leaves are
      lists with a single entry, and any subsequent entries represent children."""
      def __init__(self, rootval, children=[]):
          if isinstance(rootval, list):
              self.value = rootval[0]
              self.children = []
              for k in rootval[1:]:
                  if k:
                      self.add_child(tree(k))
          else:
              self.value = rootval
              self.children = children

      def __repr__(self):
          return str(self.to_list())

      def get_val(self):
          return self.value

      def add_child(self, node):
          self.children.append(node)

      def get_child(self, num):
          return self.children[num]

      def get_children(self):
          return self.children

      def get_depths(self, start_depth=0):
          data = [start_depth]
          for child in self.get_children():
              for child_datum in child.get_depths(start_depth + 1):
                  data.append(child_datum)
          return data

      def to_list(self):
          temp = list(self.children)
          temp.insert(0, self.value)
          return temp


  class binary_tree(tree):

      def __init__(self, rootval, children=[]):
          if isinstance(rootval, list):
              self.value = rootval[0]
              self.children = [binary_tree(x) if x else x for x in rootval[1:]
              ] + [None for x in range(2-len(rootval[1:]))]
          els(self):
          return self.children[0]

      def get_right(self):
          return self.children[1]

      def set_left(self, node):
          self.children[0] = node

      def set_right(self, node):
          self.children[1] = node

      def get_tree_height(self):
          left_height = self.left().get_tree_height() if self.left() else 0
          right_height = self.right().get_tree_height() if self.right() else 0
          return 1 + max(left_height, right_height)

      ## 9.1: Check if balanced
      def is_balanced(self):
          """ Return height of tree, or None if not balanced"""
          left_height = self.get_left().is_balanced() if self.get_left() else 0
          right_height = self.get_right().is_balanced() if self.get_right() else 0
          if left_height == None or right_height == None or abs(right_height -
                                                        left_height) > 1:
              return None
          else:
              return 1 + max(left_height, right_height)

      ## 9.2: k-balanced nodes
      # def kbalanced(self)

      ## 9.3 symmetric tree
      def is_symmetric(self):
          """Return true if symmetric tree, else false"""
          def symmetric_helper(left_node, right_node):
              if bool(left_node) != bool(right_node): # If one exists and other doesn't, False
                  return False
              if not (left_node or right_node): # If neither exists, True
                  return True
              if not left_node.get_val() == right_node.get_val(): # If both exist but have different values, False
                  return False
              # Otherwise, both exist, have same values, compare children...
              return (symmetric_helper(left_node.get_left(), right_node.get_right())
                      and symmetric_helper(left_node.get_right(), right_node.get_left()))
          return symmetric_helper(self.get_left(), self.get_right())

      ## 9.7 reconstruct from inorder and preorder or postorder
      def reconstruct_inorder_preorder(inorder, preorder):
          """Reconstruct tree from inorder and preorder lists"""
          if len(inorder) == 0:
              return None
          rootindex = inorder.index(preorder[0])
          root = binary_tree(preorder[0],
                             [binary_tree.reconstruct_inorder_preorder(inorder[:rootindex], preorder[1:1+rootindex]),
                              binary_tree.reconstruct_inorder_preorder(inorder[rootindex+1:], preorder[rootindex+1:])])
          return root

      ## 9.8 reconstruct tree from preorder transversal with null for empty nodes
      def null_reconstruct_preorder(preorder):
          if len(preorder) == 1:
              return None
          tcount, ncount = 0, 0
          left = []
          for i, k in enumerate(preorder[1:]):
              if not k == None:
                  tcount += 1
              else:
                  ncount += 1
              left.append(k)
              if ncount == tcount * 2 - (tcount - 1):
                  right = preorder[i+2:]
                  break
          root = binary_tree(preorder[0])
          if root:
              root.set_left(binary_tree.null_reconstruct_preorder(left))
              root.set_right(binary_tree.null_reconstruct_preorder(right))
          return root

      ## 9.9 Form linked list from leaf nodes of tree
      def linked_list_from_leaves(node):
          linked_list = []
          if node.get_left():
              linked_list += binary_tree.linked_list_from_leaves(node.get_left())
          if node.get_right():
              linked_list += binary_tree.linked_list_from_leaves(node.get_right())
          if not (node.get_left() or node.get_right()):
              linked_list.append(node.get_val())
          return linked_list

      # ## 9.10 Print exterior of binary tree in anti-clockwise: nodes on
      # ## path to leftmost leaf, then leaves left-right, then nodes of rightmost
      # ## to root

      # # Assuming that going left/right until first leaf matches definition; unclear
      # def binary_tree_exterior(node):
      #     def print_left_anticlockwise(node):
      #         the_list = [node.get_val()]
      #         if node.get_left():
      #             the_list += print_left_anticlockwise(node.get_left)
      #         elif node.get_right():
      #             the_list += print_left_anticlockwise(node.get_right)
      #         return the_list

      #     def print_left_anticlockwise(node):
      #         the_list = [node.get_val()]
      #         if node.get_left():
      #             the_list += print_left_anticlockwise(node.get_left)
      #         elif node.get_right():
      #             the_list += print_left_anticlockwise(node.get_right)
      #         return the_list

      ## 9.11 Lowest common ancestor
      # Assumes values are unique
      def lowest_common_ancestor(root, vals):

          # Breadth-first search
          def lca_helper(root, queue):
              if root.get_left():
                  queue.append(root.get_left())
                  ancestry[root.get_left().get_val()] = root
              if root.get_right():
                  queue.append(root.get_right())
                  ancestry[root.get_right().get_val()] = root

          # Keep track of history for path recreation
          queue = deque()
          ancestry = {root.get_val(): None}
          lca_helper(root, queue)
          while queue and not all([x in ancestry for x in vals]):
              # print(visited_queue, vals)
              curnode = queue.popleft()
              lca_helper(curnode, queue)

          # Generate paths out of node path history
          paths = {}
          for k in vals:
              paths[k] = []
              ancestry_pather = k
              while ancestry_pather:
                  paths[k].append(ancestry_pather)
                  if ancestry[ancestry_pather]:
                      ancestry_pather = ancestry[ancestry_pather].get_val()
                  else:
                      ancestry_pather = None
          # Go through paths, looking for earliest common member
          for path in paths:
              for path_member in paths[path]:
                  if all([path_member in paths[x] for x in paths]):
                      return path_member
          # Doesn't exist
          return None

  testtree = binary_tree([3, [1, [2, [3, [4]]]], [3, [2], [3]]])
  balanced_tree = binary_tree([3, [2, [1], [3]], [2, [3], [3]]])
  symmetric_tree = binary_tree([3, [2, [3], [2]], [2, [2], [3]]])
  # print(testtree.get_depths())
  # print(testtree.is_balanced())
  # print(balanced_tree.is_balanced())
  # print(testtree.is_symmetric())
  # print(symmetric_tree.is_symmetric())

  chartree = binary_tree(['H', ['B', ['F', None, None], ['E', ['A', None, None], None]], ['C', None, ['D', None, ['G', ['I', None, None], None]]]])
  chartree_inorder = ['F', 'B', 'A', 'E', 'H', 'C', 'D', 'I', 'G']
  chartree_preorder = ['H', 'B', 'F', 'E', 'A', 'C', 'D', 'G', 'I']
  # nc = binary_tree.reconstruct_inorder_preorder(chartree_inorder, chartree_preorder)
  # print(chartree.to_list())
  # print(nc)

  # chartree_preorder_marked = ['H', 'B', 'F', None, None, 'E', 'A',
  #                             None, None, None, 'C', None, 'D',
  #                             None, 'G', 'I', None, None, None]
  # print(chartree)
  # print(binary_tree.null_reconstruct_preorder(chartree_preorder_marked))

  # print (binary_tree.linked_list_from_leaves(chartree))
  print(binary_tree.lowest_common_ancestor(chartree, ['B', 'D']))
  print(binary_tree.lowest_common_ancestor(chartree, ['I', 'D', 'G']))
#+END_SRC

#+RESULTS:
: H
: D

** 10 Heap
#+BEGIN_SRC python :results output

#+END_SRC
** 11 Hash Table*

*** Closest equal entries in list (12.3)
#+BEGIN_SRC python
  from collections import defaultdict

  s = ["all", "work", "and", "no", "play", "makes", "for", "no", "work", "no", "fun", "and", "no", "results"]
  def closest_pairs(inlist):
      the_dict = defaultdict(list)
      for i, k in enumerate(inlist):
          the_dict[k].append[i]
          min_distance = 9999999
          match_list = []
      for k in the_dict:
          leng = len(the_dict[k])
          if leng > 2:
              current_distance = min([b - a for a, b in zip(k[:-1], k[1:])])
              if current_distance < min_distance:
                  min_distance = current_distance
                  match_list = []
              elif current_distance == min_distance:
                  match_list
                  


#+END_SRC
** 14 Binary Search Tree
#+BEGIN_SRC python :results output
  from itertools import takewhile

  class node:
      def __init__(self, value, left=None, right=None, parent=None):
          if isinstance(value, list):
              self.value = value[0]
              self.left, self.right = None, None
              if len(value) > 1 and value[1]:
                  self.left = node(value[1])
                  self.left.parent = self
              if len(value) > 2 and value[2]:
                  self.right = node(value[2])
                  self.right.parent = self
          else:
              self.value = value
              self.left = left
              self.right = right


      def __repr__(self):
          return str([self.value, self.left, self.right])

      # 1
      # Verify that a tree is a BST
      def is_bst(self):
          left = (self.left.is_bst() and (self.value >= self.left.value)) if self.left else True
          right = (self.right.is_bst() and (self.value <= self.right.value)) if self.right else True
          return left and right

      # 2
      # Find 'next' node in an inorder walk
      def successor(self):
          if self.right:
              child = self.right
              while child.left or child.right:
                  if child.left:
                      child = child.left
                  elif child.right:
                      child = child.right
              return child
          up = self.parent
          while up:
              if up.value > self.value:
                  return up
              up = up.parent
          return None

      # 3 Uncertain how to reconcile 'remove' function with 'do not modify
      # contents of any node' instructions.
      def insert(self, value):
          if value > self.value:
              if self.right:
                  self.right.insert(value)
              else:
                  self.right = node(value)
          else:
              if self.left:
                  self.left.insert(value)
              else:
                  self.left = node(value)

      # 4
      # Recursive and iterative searching in-order functions
      def search_recursive(self, value):
          if value < self.value:
              if self.left:
                  return self.left.search_recursive(value)
              else:
                  return None
          elif value == self.value:
              # Slightly make sure that earliest in-order node is returned
              if self.left and self.left.value == value:
                  return self.left.search_recursive(value)
              else:
                  return self
          elif value > self.value:
              if self.right:
                  return self.right.search_recursive(value)
              else:
                  return None

      def search_iterative(self, value):
          current = self
          while current:
              if current.value > value:
                  current = current.left
              elif current.value == value:
                  if current.left and current.left.value == value:
                      current = current.left
                  else:
                      return current
              elif current.value < value:
                  current = current.right
          return None

      # 5 First key larger than k:
      def search_larger(self, value):
          current = self
          bestans = None
          while current:
              if current.value > value: # Check if answer is better
                  if not bestans or current.value < bestans.value:
                      bestans = current
              if current.right and current.value < value: # Too low
                  current = current.right
              elif current.left: # Try and go left
                  current = current.left
              else: # Try and go right
                  current = current.right
          return bestans

      # 6 Min-First BST: Search
      def mf_search(self, value):
          if self.value == value:
              return self
          elif self.left and ((self.right and value < self.right.value) or not self.right):
              return self.left.mf_search(value)
          elif self.right and value > self.right.value:
              return self.right.mf_search(value)
          else:
              return None

      # 7 BST From Sorted Array
      @staticmethod
      def list_to_BST(ins):
          if len(ins) == 1:
              return node(ins[0])
          if len(ins) == 2:
              return node(ins[1], node(ins[0]))
          midpt = int(len(ins)/2)
          return node(ins[midpt], node.list_to_BST(ins[:midpt]), node.list_to_BST(ins[midpt+1:]))

      # 8 BST From Sorted Linked List
      # @staticmethod
      # def linked_list_to_BST(ins):

      # 9 BST to Sorted Doubly Linked List

      # Some LL operations. These are here implemented in linear time,
      # in an actual class they can be implemented in constant time.
      def head(self):
          current = self
          while current.left:
              current = current.left
          return current

      def tail(self):
          current = self
          while current.right:
              current = current.right
          return current
      
      @staticmethod
      def BST_to_linked_list(node):
          if node.left:
              left = node.BST_to_linked_list(node.left)[1]
              left.right = node
              node.left = left
          if node.right:
              right = node.BST_to_linked_list(node.right)[0]
              right.left = node
              node.right = right
          return (node.head(), node.tail())

      @staticmethod
      def string_linked_list(head):
          """Because a linked list isn't a class and __repr__ isn't overloaded,
          it can't be directly printed due to any two neighboring nodes containing
          recursive references to each other."""
          accustr = "%d " % head.value
          while head.right:
              head = head.right
              accustr += "%d " % head.value
          return accustr

      # 11 Find k largest elements in a BST
      def largest_elements(self, num):
          total = [] 
          if self.right:
              total = self.right.largest_elements(num)
          if len(total) < num:
              total = [self.value] + total
          if len(total) < num and self.left:
              total = self.left.largest_elements(num - len(total)) + total
          return total[-num:]

      # 12 BST recreation from only preorder. Trivial, just left head = last
      # instead of first.
      @staticmethod
      def BST_from_preorder(preorder):
          if preorder == []:
              return None
          head = preorder[0]
          left = node.BST_from_preorder([x for x in preorder[1:] if x < head])
          right = node.BST_from_preorder([x for x in preorder[1:] if x >= head])
          return node(head, left, right)

      # 13 Lowest common ancestor assuming unique indices
      def lowest_common_ancestor(self, a, b):
          a, b = min(a, b), max(a, b)
          # self.left has to exist if this condition holds and a and b exist
          if b < self.value:
              return self.left.lowest_common_ancestor(a, b)
          elif a > self.value:
              return self.right.lowest_common_ancestor(a, b)
          else:
              return self

      # 14 Descendant and ancestor
      def descendant_and_ancestor(self, m, aset):
          current = self
          target = m
          while current.left or current.right:
              # If met, False if exactly one value hasn't been removed from set
              if current.value == m:
                  if len(aset) != 1:
                      return False
                  target = aset[0] # Now looking for remaining aset member, not m
              # If in aset, remove from aset
              elif current.value in aset:
                  aset.remove(current.value)
              #  If aset empty, True
              if not aset:
                  return True
              # Navigate down
              elif current.value > target and current.left:
                  current = current.left
              elif current.value <= target and current.right:
                  current = current.right
          return False

      # 15 Range-query, find list of members that fall within a given range.
      def range_query(self, a, b):
          a, b = min(a, b), max(a, b)
          if b < self.value:
              return [] if not self.left else self.left.range_query(a, b)
          elif a > self.value:
              return [] if not self.right else self.right.range_query(a, b)
          elif a <= self.value and b >= self.value:
              left = [] if not self.left else self.left.range_query(a, self.value)
              right = [] if not self.right else self.right.range_query(self.value, b)
              return left + [self.value] + right

      # 16 Minimize distance in three sorted arrays. Distance[i,j,k] = maximum
      # distance between any two with A[i], B[j], C[k]. Return triple i,j,k so
      # that distance is minimum.
      # def min_3_dist(arrays):
      #     def get_dist(arrays, indices):
      #         return ma

       
  test_bst = node([5, [1], [7]])
  test_bst_2 = node([5, [2, [1]], [7, None, [9]]])
  bst_141 = node([19, [7,
                      [3, [2], [5]],
                      [11, None, [17, [13]]]],
                     [43,
                      [23,
                       None,
                       [37, [29, None, [31]], [41]]],
                      [47,
                       None, [53]]]])
  bst_142 = node([108, [108, [-10, [-14], [2]], [108]], [285, [243], [285,
                  None, [401]]]])
  bsts = [test_bst, test_bst_2]

  mf_143 = node([2, [3, None, [5, [7, [11]]]], [13, [17], [19, [23]]]])



  def test_is_bst(bsts):
      for bst in bsts:
          assert bst.is_bst()

  def test_successor(bsts):
      assert bsts[0].left.successor().value == 5
      assert bsts[1].right.successor().value == 9

  def test_search():
      assert bst_142.search_iterative(108) == bst_142.left
      assert bst_142.search_iterative(285) == bst_142.right
      assert bst_142.search_iterative(143) == None
      assert bst_142.search_recursive(108) == bst_142.left
      assert bst_142.search_recursive(285) == bst_142.right
      assert bst_142.search_recursive(143) == None

  def test_search_larger():
      assert bst_141.search_larger(23) == bst_141.right.left.right.left

  def test_mf_search():
      assert not mf_143.mf_search(12)
      assert not mf_143.mf_search(97)
      assert mf_143.mf_search(11)
      assert mf_143.mf_search(3)

  def test_create_BST():
      assert node.list_to_BST(sorted([1, 4, 6, 3, 4, 87, 9, 3])).is_bst()

  def test_BST_to_linked_list():
      """Modifies underlying structure, so custom tree created here."""
      the_tree = node([108, [108, [-10, [-14], [2]], [108]], [285, [243], [285,
                  None, [401]]]])
      BST_ll = [int(x) for x in node.string_linked_list(
          node.BST_to_linked_list(the_tree)[0]).split()]
      assert BST_ll == sorted(BST_ll)

  def test_largest_elements():
      assert bst_142.largest_elements(3) == [285, 285, 401]
      
  def test_lowest_common_ancestor():
      assert bst_141.lowest_common_ancestor(29, 53).value == 43
      assert bst_141.lowest_common_ancestor(2, 13).value == 7
      assert bst_141.lowest_common_ancestor(5, 31).value == 19

  def test_descendant_and_ancestor():
      assert bst_141.descendant_and_ancestor(23, [19, 37])
      assert not bst_141.descendant_and_ancestor(23, [43, 53])

  def test_range_query():
      assert bst_141.range_query(11, 20) == [11, 13, 17, 19]
      
  test_is_bst([test_bst, test_bst_2, bst_141, bst_142])
  test_successor(bsts)
  test_search()
  test_search_larger()
  test_mf_search()
  test_create_BST()
  test_BST_to_linked_list()
  test_largest_elements()
  test_lowest_common_ancestor()
  test_descendant_and_ancestor()
#+END_SRC
** 15 Meta-algorithms
*** DONE Mergesort
CLOSED: [2015-05-24 Sun 14:30]
Personal mergesort implementation. 
#+BEGIN_SRC python :output results :tangle mergesort.py
  from collections import deque

  vals = [1, 4, 2, 67, 8, 3, 4, 7, 4]

  def mergesort(vals):
      if len(vals) < 2:
          return vals
      mid = int(len(vals)/2)
      left = deque(mergesort(vals[:mid]))
      right = deque(mergesort(vals[mid:]))
      out = []
      while left or right:
          if left and right:
              if left[0] < right[0]:
                  out.append(left.popleft())
              else:
                  out.append(right.popleft())
          elif left:
              out.append(left.popleft())
          elif right:
              out.append(right.popleft())
      return out

  print(mergesort(vals))


      

#+END_SRC

#+RESULTS:
: None

*** DONE 1 Skyline Drawing
'Draw' a skyline given a collection of buildings described by leftx, rightx, and height coordinates. Implementation
changes the list into a list of non-overlapping sections, first in n**2 and then in nlogn time.
CLOSED: [2015-05-24 Sun 14:30]
#+BEGIN_SRC python :results output
  from collections import namedtuple

  ## Given a list of buildings represented by x_left, x_right, and height, efficiently compute the skyline generated by them.
  building = namedtuple('building', ['left', 'right', 'height'])

  buildings = [building(1, 3, 3), building(2, 4, 2), building(3, 5, 5)]
  buildings2 = [building(1, 5, 1), building(2, 4, 2)]
  # One half-enclose another -> truncate smaller
  def merge_buildings(buildings):
      buildings_out = []
      for building1 in buildings:
          touched = False
          buildings_to_append = []
          for building2 in buildings:
              # Same building
              if building1 == building2:
                  continue
              # Current building1 is eclipsed by building2
              elif (building1.left > building2.left and
                    building1.height < building2.height and
                    building1.right < building2.height):
                  break
              # Cut off on right
              if (building1.left < building2.left and
                    building1.right > building2.left and
                    building1.height < building2.height):
                  buildings_to_append.append(
                      building(building1.left, building2.left, building1.height))
                  touched = True
              # Cut off on left
              if (building1.right > building2.right and
                    building1.left < building2.right and
                    building1.height < building2.height):
                  buildings_to_append.append(
                      building(building2.right, building1.right, building1.height))
                  touched = True
              # Not cut off at all
              if not touched:
                  buildings_to_append.append(building1)
          for building_single in buildings_to_append:
              buildings_out.append(building_single)
      return buildings_out

  def merge_buildings_faster(buildings):
      if len(buildings) < 4:
          return merge_buildings(buildings)
      midpoint = int(len(buildings)/2)
      mid_x = (buildings[midpoint].left + buildings[midpoint.right]) / 2

      # Split into three groups, apply recursively on edges, sort results 
      buildings_left = sorted(
          merge_buildings_faster([x for x in buildings if (x.left + x.right)/2 < mid_x]),
  key=lambda x: x.right)
      buildings_right = sorted(
          merge_buildings_faster([x for x in buildings if (x.left + x.right)/2 >= mid_x]),
          key=lambda x: x.left)

      buildings_left_finished = [x for x in buildings_left if x.right < mid_x]
      buildings_right_finished = [x for x in buildings_right if x.left > mid_x]
      buildings_center_unfinished = ([x for x in buildings_left if x.right >= mid_x] +
                                     [x for x in buildings_right if x.left <= mid_x])
      buildings_center_finished = merge_buildings_faster(buildings_center_unfinished)
      buildings_out = (buildings_left_finished +
                       buildings_center_finished +
                       buildings_right_finished)
      return buildings_out
      

  # print(merge_buildings(buildings))
  # print(merge_buildings(buildings2))
  print(merge_buildings(buildings) == merge_buildings_faster(buildings))
  print(merge_buildings(buildings2) == merge_buildings_faster(buildings2))
#+END_SRC

*** DONE 2 Counting Inversions
CLOSED: [2015-05-24 Sun 14:30]
Array A of n numbers, returns number of pairs of indicies so that i < j and A[i] and A[j]. nlogn
#+BEGIN_SRC python :results output
  A = [3, 8, 2, 4, 6, 3]

  ## Basic, n^2
  def count_inv1(A):
      sum = 0
      for i, num1 in enumerate(A):
          for k, num2 in enumerate(A):
              if i < k and num1 > num2:
                  sum += 1
      return sum

  ## Mergesort-like, nlogn
  def count_inv2(A):
      if len(A) < 5:
          return count_inv1(A) 
      mid = int(len(A)/2)
      left = count_inv2(A[:mid])
      right = count_inv2(A[mid:])
      sum = left + right
      for a in A[:mid]:
          for b in A[mid:]:
              if a > b:
                  sum += 1
      return sum

  print(count_inv2(A))
      
#+END_SRC

#+RESULTS:
: 7

*** DONE 3 Nearest Points in the Plane
CLOSED: [2015-05-24 Sun 14:30]
Find the nearest points in a plane, preferably without comparing every single pair.
#+BEGIN_SRC python :results output
  from collections import namedtuple

  p = namedtuple('p', ['x', 'y'])
  sol = namedtuple('sol', ['p1', 'p2', 'dist'])

  points = [p(1, 3), p(4, 2), p(8, 3), p(5, 5), p(3, 5)]

  def find_minimum_distance(points):
      def distance(p1, p2):
           return ((p2.x - p1.x)**2 + (p2.y - p1.y)**2)

      def brute_force(points):
          bestsol = sol(None, None, 9999999)
          for i, a in enumerate(points):
              for b in points[i:]:
                  if a != b and distance(a, b) < bestsol.dist:
                      bestsol = sol(a, b, distance(a, b))
          return bestsol

      # Handle few points
      if len(points) < 7:
          return brute_force(points)

      points = points.sort(key=lambda x: x.y)

      mid = int(len(points)/2)
      left = [x for x in points[:mid]]
      right = [x for x in points[mid:]]
      sol_left = find_minimum_distance(left)
      sol_right = find_minimum_distance(right)
      min_sol = min(sol_left, sol_right, key=lambda x: x.dist)
      # Look at overlaps
      center_y = points[mid].y
      overlap_points = [x for x in points if
                        x.y < center_y + min_sol.dist or
                        x.y > center_y - min_sol.dist]

      best_overlap = brute_force(overlap_points)
      return min(min_sol, best_overlap, key=sol.dist)

  print(find_minimum_distance(points))
#+END_SRC

#+RESULTS:
: sol(p1=p(x=5, y=5), p2=p(x=3, y=5), dist=4)

*** DONE 4 Tree Diameter
CLOSED: [2015-05-24 Sun 14:30]
Find the diameter of a tree. It's the maximum distance from one node to another
#+BEGIN_SRC python
  from collections import namedtuple

  node = namedtuple('node', ['value', 'cost', 'children'])

  def find_perimeter(root):
      # Base Case
      if not root.children:
          return (root.cost, 0) # root, height, perimeter

      # Run on all children
      child_info = [find_perimeter(child) for child in root.children]

      # Perimeter candidate based on two longest subtree heights
      height_sorted_children = sorted(child_info, key = lambda x: x[0])

      # Height
      height = height_sorted_children[-1][0] + root.cost
      # Perimeter candidates based on children perimeters
      children_perimeters = list(list(zip(*child_info))[1])
      if len(root.children) > 1:
          height_induced_perimeter = height_sorted_children[-1][0] + height_sorted_children[-2][0]
      else:
          height_induced_perimeter = 0

      return (height, max(children_perimeters + [height_induced_perimeter]))

  b = node('b', 0, [node('a', 14, []), node('c', 7, [node('d', 4, []), node('l', 3, [])])])
  print(find_perimeter(b))
#+END_SRC
*** TODO 6 Longest nondecreasing subsequence
Longest nondecreasing subsequence of a sequence. Doesn't have to be contiguous


#+BEGIN_SRC python :results output
  from collections import namedtuple

  # Longest nondecreasing subsequence
  seq = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9]


  def longest_nondec_subseq(seq):
      members = {}
      for a in seq:
          if a < min(members):
              members[a] = None
          
#+END_SRC
*** TODO 7 Longest subarray where sum <= k
Longest sequence the sum of which is under the cap. 
#+BEGIN_SRC python :results output
  from collections import deque, namedtuple
  from itertools import accumulate
  from bisect import bisect_right

  sol = namedtuple('sol', ['list', 'len', 'sum'])

  array = [431, -15, 639, 342, -14, 565, -924, 635, 167, -70]

  def longest_subarray_capped_sum(array, cap):
      """ Efficient (linear-time), but flawed; may not always get the best answer"""
      best = deque([])
      bestsum = 0
      bestlen = 0
      curr = deque([])
      currsum = 0
      currlen = 0
      for k in array:
          curr.append(k)
          currsum += k
          currlen += 1
          while currsum > cap:
              currsum -= curr.popleft()
              currlen -= 1
          if currlen > bestlen:
              best = deque(curr)
              bestsum = int(currsum)
              bestlen = int(currlen)
          print(curr)
      return best

  def longest_subarray_capped_sum2(array, cap):
      def generate_frontier(array):
          mini = 999999999999 
          for a in reversed(array):
              if a < mini:
                  mini = a
              yield mini
      prefix_sum_array = list(accumulate(array))
      frontier = list(reversed(list(generate_frontier(prefix_sum_array))))

      maxseq = (0, 0)
      for i, a in enumerate(array):
          j = bisect_right(frontier, prefix_sum_array[i] + cap)
          if (j - i) > maxseq[1] - maxseq[0] and array[j-1] - array[i] < cap:
              maxseq = (i, j)

      return array[maxseq[0]:maxseq[1]]

  print(array)

  print(longest_subarray_capped_sum2(array, 184))
#+END_SRC
*** TODO 11 Levenshtein Distance
Algorithm to find 'distance' between two strings, measured in insertion, deletion and replacement operations.
#+BEGIN_SRC python :results output


  def levenshtein(word1, word2):
      insertions = abs(len(word1) - len(word2))
      for a in word1:
          
#+END_SRC
** 16 Graph
*** DONE 2 Transform one string into another
CLOSED: [2015-05-24 Sun 20:45]
Find the shortest paths to connect a list of words using a given dictionary. Can either only use replacements, or include off-by-1 character insertions/deletions. Bytearrays used for efficiency of single-character operations (they're mutable). 
#+BEGIN_SRC python :results output
  from collections import deque

  # 'words' is assumed to be input file of words separated by newlines. Imported here
  f = open('words', 'r')
  wordlist = f.readlines()
  wordlist = [bytes(x.strip("\n").lower(), 'ASCII') for x in wordlist]
  wordict = {}
  for line in wordlist:
      wordict[line] = []
      f.close()

  letters = bytearray(b'abcdefghijklmnopqrstuvwxyz')

  def find_word_path(words, global_wordict, allow_insertions=False):
      """Find shortest path between the list of passed words, using a global dictionary.
      Strategy:
      For each word, breadth-first expansion until all the 'globes' meet."""
      def maybe_add_word(word, new_word):
          """Slight abstraction, see if the generated word should be added and if it should,
          add it"""
          if bytes(new_word) in global_wordict and bytes(new_word) not in mworddict[word]:
              mworddict[word][bytes(new_word)] = bytes(current_word)
              mqueue[word].append(new_word)
              new_words.add(bytes(new_word))        

      words = [bytes(word, 'ASCII') for word in words]
      mworddict = {word: {word: None} for word in words}
      mqueue = {word: deque([bytearray(word)]) for word in words}

      while(1):
          new_words = set()        
          for word in words:
              try:
                  current_word = bytearray(mqueue[word].pop())
              except:
                  return None
              for index, letter in enumerate(current_word):
                  ## Letter replacements
                  for replacement_letter in letters:
                      new_word = bytearray(current_word)
                      new_word[index] = replacement_letter
                      maybe_add_word(word, new_word)
                  if allow_insertions:
                      ## Letter insertions
                      for new_letter in letters:
                          new_word = bytearray(current_word)
                          new_word.insert(index, new_letter)
                          maybe_add_word(word, new_word)
                      ## Letter Deletions
                          new_word = bytearray(current_word)
                          del new_word[index]
                          maybe_add_word(word, new_word)

          # Check whether any newly_added word is globally visible                    
          for new_word in new_words:
              if all([new_word in mworddict[word] for word in mworddict]):

                  # If it is, extract paths to that word from every starting word
                  paths = {word.decode('utf-8'): [] for word in words}
                  for word in words:
                      word_string = word.decode('utf-8')
                      word_iterator = new_word
                      while(word_iterator):
                          paths[word_string].append(word_iterator)
                          word_iterator = mworddict[word][word_iterator]
                      paths[word_string].reverse()
                      paths[word_string] = [x.decode('utf-8') for x in paths[word_string]]
                  return paths
                      
  print(find_word_path(["what", "cat", "hearse"], wordict, True))
  print(find_word_path(["what", "when"], wordict))    
      

#+END_SRC

#+RESULTS:
: {'cat': ['cat', 'hat'], 'hearse': ['hearse', 'hears', 'hearts', 'hearth', 'heath', 'heat', 'hat'], 'what': ['what', 'hat']}
: {'when': ['when', 'whet'], 'what': ['what', 'whet']}

*** DONE 5 Extended Contacts
CLOSED: [2015-05-24 Sun 22:24]
Let C be extended contact of A if contact of A or contact of extended contact of A. Take social network, computes each individual's extended contacts.
#+BEGIN_SRC python :results output
  from collections import namedtuple

  p = namedtuple('p', ['name', 'contacts', 'extended'])

  b = p('b', [], [])
  a = p('a', [b], [])
  b.contacts.append(c)
  c = p('c', [a], [])

  people = [a, b, c]

  def generate_extended_contacts(people):
      for person in people:
          person.extended.extend(person.contacts)
      while 1:
          changed = False
          for person in people:
              for ex in list(person.extended):
                  for ex_contact in list(ex.contacts):
                      if ex_contact not in person.extended and ex_contact.name != person.name:
                          person.extended.append(ex_contact)
                          changed = True
          if changed == False: # Convergence
              return people

  def print_person(person):
      print(person.name + ": " +
            str([x.name for x in person.contacts]) + " / " +
            str([x.name for x in person.extended]))

  [print_person(x) for x in generate_extended_contacts(people)]

#+END_SRC

#+RESULTS:

*** DONE 10 Quickest Route
CLOSED: [2015-05-24 Sun 18:55]
Flight = (start time, originating city, destination city, arrival time). Daily. 60 minutes to transfer. Compute fastest from city a to city b.
#+BEGIN_SRC python :results output :tangle flights_shortest_time.py
  from collections import namedtuple, defaultdict, deque

  ## Given list of flights, some amount of transfer time, find shortest time-path between two given cities.
  # Will be assuming that times are from 0-100, with stopover time being 10.

  ## TODO:
  # Uncertain whether the sort of the flights in each iteration is sufficient to ensure that cities will always be reached in time-order. If not, then the condition for detecting 'convergence' is incorrect.
  city = namedtuple("city", ["name", "flights"])
  flight = namedtuple("flight", ["tstart", "tstop", "cstart", "cstop"])
  pathnode = namedtuple("pathnode", ["last", "time"])

  a = city('a', [])
  b = city('b', [])
  c = city('c', [])

  # a -> b -> c should be faster than a>c
  flights = [flight(15, 40, a, b),
             flight(55, 80, b, c),
             flight(40, 90, a, c)
  ]

  # Reverse-link each flight to each city
  for flight in flights:
      flight.cstart.flights.append(flight)

  def shortest_path(citya, cityb):
      shortest_paths = {citya.name: pathnode(None, 0)}
      queue = deque()
      queue.append(citya)
      destination_reached = False
      
      while queue:
          cur_city = queue.popleft()

          if cityb.name == cur_city.name:
              destination_reached = True

          if destination_reached:
              parent = cityb.name
              path = []
              while parent:
                  path.append(parent)
                  parent = shortest_paths[parent][0]
              return path
          
          for flight in sorted(cur_city.flights, key = lambda x: x.tstop):
              if shortest_paths[cur_city.name][1] % 100 + 10 < flight.tstart:
                  best_time_relative = flight.tstop
              else:
                  best_time_relative = flight.tstop + 100
              best_time = int(shortest_paths[cur_city.name][1] / 100) * 100 + best_time_relative
              if (flight.cstop.name in shortest_paths and
                  best_time < shortest_paths[flight.cstop.name][1]):
                  shortest_paths[flight.cstop.name] = (cur_city.name, best_time)

              if flight.cstop.name not in shortest_paths:
                  shortest_paths[flight.cstop.name] = (cur_city.name, best_time)
                  queue.append(flight.cstop)
                  

  print(shortest_path(a, c))
  assert shortest_path(a, c) == ['c', 'b', 'a']
              
#+END_SRC

#+RESULTS:

*** 11 Road Network
#+BEGIN_SRC python :results output



#+END_SRC
*** 12 Arbitrage
Exchange rates specified by 2D array. Test if arbitrage is possible. Probably a very simple solution possible with linear algebra.
#+BEGIN_SRC python :results output
  exchange_rates = [[1, 2, 3],
                    [2, 3, 4],

#+END_SRC
* Trees
** Building tree from inorder and postorder.
Assignment: 
*** tree 1
       a
    b     c
  d   e    f
   g      h    
+ inorder:  dgbeachf
+ postorder: gdebhfca
*** tree 2
    f
  h
+ inorder:  hf
+ postorder: hf

*** tree 3
b
  e
+ inorder: be
+ postorder: eb

*** tree 4
g
+ inorder: g
+ postorder: g
*** solution
#+BEGIN_SRC python
  inorder = ['d', 'g', 'b', 'e', 'a', 'c', 'h', 'f']
  postorder  = ['g', 'd', 'e', 'b', 'h', 'f', 'c', 'a']
  def build_tree(ino, posto):
      if len(ino) == 0:
          return None
      elif len(ino) == 1:
          return (ino, None, None)
      curnode = posto[-1]
      in_index = ino.index(curnode)
      leftin = ino[0:in_index]
      rightin = ino[in_index+1:]
      leftpost = posto[0:in_index]
      rightpost = posto[in_index:-1]
      left = build_tree(leftin, leftpost)
      right = build_tree(rightin, rightpost)
      return (curnode, left, right)
  return build_tree(inorder, postorder)        
#+END_SRC

#+RESULTS:
| a | (b (d None ((g) None None)) ((e) None None)) | (c None (f ((h) None None) None)) |

 
** Lowest common ancestor
*** Generic tree, multiple common values
Tries to find the closest common ancestor in a tree between a list of values. Little error-checking is done.
   a
  b  c
    d  e

#+BEGIN_SRC python
  #!/usr/bin/env python

  tree = ('a', ('b', None, None), ('c', ('d', None, None), ('e', None, None)))

  ## First call the helper, then use that dictionary to find lowest common member of the lists.
  def lowest_common_ancestor(vals, head):
      ancestor_paths = lowest_common_ancestor_helper(vals, head, [], {})
      print ancestor_paths
      bestans = head[0]
      for k in ancestor_paths[vals[0]]:
          for q in ancestor_paths:
              if k not in ancestor_paths[q]:
                  return bestans
          bestans = k
      return bestans
          
  ## Return a dictionary mapping each value we're looking at to a list repersenting its path.
  def lowest_common_ancestor_helper(vals, head, path, ans):
      for k in vals:
          if k == head[0]:
              ans[k] = path    
      if head[1] != None:
          x = list(path)
          x.append(head[0])
          lowest_common_ancestor_helper(vals, head[1], x, ans)
      if head[2] != None:
          x = list(path)
          x.append(head[0])        
          lowest_common_ancestor_helper(vals, head[2], x, ans)
      return ans

  return lowest_common_ancestor(['d', 'e'], tree)

#+END_SRC

#+RESULTS:

*** BST, two common values
Assumes tree is a BST, only takes two values.
    5
   3  7
 1 4 6 8

#+BEGIN_SRC python
  tree = (5, (3, (1, None, None), (4, None, None)), (7, (6, None, None), (8, None, None)))

  def lowest_common_ancestor(a, b, tree):
      if (min(a,b) < tree[0]) and (max(a,b) > tree[0]):
          return tree[0]
      elif b < tree[0]:
          return lowest_common_ancestor(a, b, tree[1])
      else:
          return lowest_common_ancestor(a, b, tree[2])

  return lowest_common_ancestor(6, 4, tree)
      
#+END_SRC 

#+RESULTS:
: 5

** Balance an unbalanced BST
Balance a tree, knowing that the left side is larger than the right.
       7
     5   8
   4  6
 3

#+BEGIN_SRC python
tree = [7, [5, [4, [3, [2, None, None], None], None], [6, None, None]], [8, None, None]]

def balance_once(head):
    old_head = list(head)
    head = head[1]
    old_head[1] = head[2]
    head[2] = old_head
    return head

return balance_once(tree)
#+END_SRC

#+RESULTS:
| 5 | (4 (3 (2 None None) None) None) | (7 (6 None None) (8 None None)) |

* Graph
** Six degrees of Kevin Bacon
Given a 'list' of movies and their associated cast, devise and implement a way to find the shortest path between any actor and Kevin Bacon.

*** Strategy
Actors are nodes, movies are edges between them.

Start at actor. Breadth first search of all neighbors. Maintain dictionary of visited actors and shortest paths to them. Once all actors exhausted or no more moves available, return shortest path to Kevin Bacon.

Visit a node if never visited. Update path. New path will never be shorter than old due to this being a breadth-first search.

#+BEGIN_SRC python
  from collections import deque

  class actor:
      def __init__(self, name, neighbors):
          self.name = name
          self.neighbors = neighbors
          
      def getneighbors(self):
          return self.neighbors

      def setneighbors(self, neighbors):
          self.neighbors = neighbors

      def getname(self):
          return self.name        

  w = actor('w', [])
  x = actor('x', [])
  y = actor('y', [])
  z = actor('z', [])

  w.setneighbors([z, y])
  x.setneighbors([y])
  y.setneighbors([x, z, w])
  z.setneighbors([y, w])


  def shortest_path(init, searchee):
      path_dict = {}
      Q = deque()
      Q.append(init)
      path_dict[init] = []
      while Q:
          acts_visited = [] # In case there are two edges connecting same actors
          curnode = Q.pop()
          if curnode == searchee:
              path_dict[searchee].append(searchee)
              return path_dict[searchee]
          for k in curnode.getneighbors():
              if (k not in acts_visited) and k not in path_dict:
                  Q.append(k)
                  acts_visited.append(k)
                  path_dict[k] = list(path_dict[curnode])
                  path_dict[k].append(curnode)

  return [k.getname() for k in shortest_path(x, z)]                

#+END_SRC

#+RESULTS:
| x | y | z |

** Word-neighbors
You're given two words. Find the shortest path between them, where a single move entails switching a single letter in each word (or inserting one), and each intermediary step must be a valid word. 

First step is generating the neighbors for every word. This script does that, both for the case with only letter-swapping and then with letter-insertion as well. This is then pickled, so it doesn't have to be done again and again while testing.
#+BEGIN_SRC python
  import pickle

  f = open('wordlist.txt', 'r')
  wordlist = f.readlines()
  wordlist = [x.strip("\n").lower() for x in wordlist]
  wordict = {}
  for line in wordlist:
      wordict[line] = []
  f.close()

  letters = list('abcdefghijklmnopqrstuvwxyz')
  for word in wordlist:
      for i, letter in enumerate(list(word)): # Letter replacement
          for repletter in letters:
              neword = list(word)            
              neword[i] = repletter
              temp = "".join(neword)
              if temp in wordict and temp not in wordict[word]:
                  wordict[word].append(temp)
  pikl_file = open('replacement_wordict.pkl', 'wb') 
  pickle.dump(wordict, pikl_file)
  pikl_file.close()

  for word in wordlist:                
      for i in range(len(word)+1): # letter insertion
          for repletter in letters:
              neword = list(word)            
              neword.insert(i, repletter)
              temp = "".join(neword)
              if temp in wordict and temp not in wordict[word]:
                  wordict[word].append(temp)

  pikl_file = open('replacement_and_insertion_wordict.pkl', 'wb') 
  pickle.dump(wordict, pikl_file)
  pikl_file.close()                
#+END_SRC

#+RESULTS:
: None


This code implements a simple algorithm, which travels in a single direction between two words. It's inefficient, as looking searching for a match from two directions will search exponentially fewer words.
#+BEGIN_SRC python
  from collections import deque
  import pickle

  f = open('wordlist.txt', 'r')                      
  wordlist = f.readlines()                           
  wordlist = [x.strip("\n").lower() for x in wordlist]
  f.close()

  pikl_file = open('replacement_and_insertion_wordict.pkl', 'rb')
  wordict = pickle.load(pikl_file)
  pikl_file.close()
      
  def findpath(word1, word2):
      stack = deque()
      stack.append(word1)
      visitedWords = {word1:1}
      while 1:
          if stack:
              curnode = stack.popleft()
          else:
              return None
          for k in wordict[curnode]:
              if (k == word2):
                  m = visitedWords[curnode]
                  theanswer = [k, curnode]
                  while m != 1:
                      theanswer.append(m)
                      m = visitedWords[m]                    
                  return theanswer
              if k not in visitedWords:
                  visitedWords[k] = curnode
                  stack.append(k)

  return findpath('a', 'bent')

#+END_SRC

#+RESULTS:
| bent | ben | be | b | a |

This script does a similar thing, but instead of working with two words, it works for n words. And it's faster, because it approaches from all sides! Basically, it's looking for the shortest paths to connect all the given words.

#+BEGIN_SRC python
#!/usr/bin/env python
from collections import deque
import pickle

f = open('wordlist.txt', 'r')                      
wordlist = f.readlines()                           
wordlist = [x.strip("\n").lower() for x in wordlist]
f.close()

pikl_file = open('replacement_and_insertion_wordict.pkl', 'rb')
wordict = pickle.load(pikl_file)
pikl_file.close()

def findpath_multiple(input_list):
    visitedwords = [{word: None} for word in input_list]
    paths = [[] for word in input_list]
    deques = [deque() for word in input_list]
    curword = [1 for word in input_list]
    for k in range(len(deques)):
        deques[k].append(input_list[k])

    while 1:
        for commonword in visitedwords[0]:
            if all([commonword in visitedwords[x] for x in range(0, len(input_list))]):
                for i, word in enumerate(input_list):
                    m = commonword
                    while m != None:
                        paths[i].append(m)
                        m = visitedwords[i][m]
                return(commonword, paths)
        for i, word in enumerate(input_list):
            if deques[i]:
                curword[i] = deques[i].popleft()
            else:
                return None
            for neighbor in wordict[curword[i]]:
                if neighbor not in visitedwords[i]:
                    visitedwords[i][neighbor] = curword[i]
                    deques[i].append(neighbor)
        
return(findpath_multiple(['bath', 'kent', 'what']))
#+END_SRC

#+RESULTS:
| cast | ((cast cash bash bath) (cast cant cent kent) (cast cost coat chat what)) |

* Sequence
** Longest nondecreasing subsequence
EPI specified an nlogn solution, here's an n*m solution, where m is the maximum length of a nondecreasing subsequence.
#+BEGIN_SRC python :results output
  from collections import deque

  sequence = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9]

  def longest_nondecreasing_subsequence(sequence):
      paths = {1: deque([sequence[0]])}
      for member in sequence[1:]:
          for path in paths:
              if paths[path][-1] > member and ((len(paths[path]) < 2) or
                                               (paths[path][-2] < member)):
                  paths[path][-1] = member
              if (paths[path][-1] < member and
                    (((path + 1) not in paths) or
                    (paths[path + 1][-1] > member))):
                  paths[path + 1] = paths[path]
                  paths[path + 1].append(member)
                  break
      return list(sorted(list(paths.items()), key=lambda x: x[0], reverse=True)[0][1])

  print(longest_nondecreasing_subsequence(sequence))
#+END_SRC
nlogn solution
#+BEGIN_SRC python :results output
  import bisect
  from collections import deque

  sequence = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9]

  def longest_nondecreasing_subsequence(sequence):
      tops = [sequence[0]]
      seqs = [deque([sequence[0]])]
      for i, member in enumerate(sequence[1:]):
          # Find insertion point
          fit = bisect.bisect_right(tops, member)

          # Case that it's better than something its own size
          if len(seqs) > fit and seqs[fit][-1] > member:
              seqs[fit] = deque(seqs[fit-1])
              seqs[fit].append(member)
              tops[fit] = member

          # Case that it makes a bigger biggest
          elif len(seqs) == fit and member > seqs[fit-1][-1]:
              seqs.append(deque(seqs[fit - 1]))
              seqs[fit].append(member)
              tops.append(member)
      return list(seqs[-1])
          
  print(longest_nondecreasing_subsequence(sequence))
#+END_SRC
** Optimal Buy/Sell for sequence
** 
Given an array of stock prices, specify which indices to buy and which to sell to maximize profit.
#+BEGIN_SRC python :results output

  sequence1 = [3, 4, 8, 3, 7, 6, 1]
  expected_output1 = [1, 1, -1, 1, -1, -1, -1] # 1 is buy/hold, -1 is sell/hold

  sequence2 = [1, 2, 3, 4, 5, 3, 2, 4, 5]
  expected_output2 = [1, 1, 1, 1, -1, -1, 1, 1, -1]

  def maximize_profit(inlist):
      state = -1
      output = []
      for i, member in enumerate(inlist):        
          if state == -1:
              if len(inlist) > i + 1 and inlist[i+1] > member:
                  state = 1
              else:
                  state = -1
          if state == 1:
              if len(inlist) > i + 1 and inlist[i+1] <= member:
                  state = -1
              elif len(inlist) <= i + 1:
                  state = -1
              else:
                  state = 1
          output.append(state)
      return output

  out1 = maximize_profit(sequence1)
  out2 = maximize_profit(sequence2)
  assert expected_output1 == out1
  assert expected_output2 == out2
  print(out1)
  print(out2)
#+END_SRC
